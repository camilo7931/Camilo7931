from sys import stdin
from sys import  setrecursionlimit

setrecursionlimit(100000)

C = 0
def dfs_tarjan(u):
    global C
    low[u] = depth[u] = C
    C += 1
    aristas_arbol = 0
    for v in G[u][0]:
        
        if(depth[v] == -1): #(u,v) es el retorno hacia el padre
            # depth[v] = depth[u] + 1
            papa[v] = u
            #C += 1
            aristas_arbol+=1
            dfs_tarjan(v)
            low[u] = min(low[u],low[v])

            if(u == 0 and aristas_arbol >= 2):
                G[u][1][1] +=1

            if(u != 0 and low[v] >= depth[u]):
                #print(G[u][1])
                G[u][1][1] +=1
            
        elif(v == papa[u]): #(u,v) es parte del arbol
            pass
        else:
            #(u,v) es un back-edge
            low[u] = min(low[u],depth[v])
    #print(u, aristas_arbol)

def solve(y):
    global low,depth,papa,C
    n = len(G)
    low = [-1 for i in range(n)]
    depth = [-1 for i in range(n)]
    papa = [-1 for i in range(n)]
    cont = 0
    C = 0
    depth[0] = 0
    dfs_tarjan(0)

    H = sorted(G, key=lambda item: -item[1][1])

    for i in range(y):
        print(H[i][1][0],H[i][1][1])
    return 

G = None

def main():
    global G, subGra
    x,y = list(map(int,stdin.readline().split()))
    while(x + y != 0 and x + y != -2):
        G = [[[],[i,1]] for i in range(x)]
        m,n = list(map(int,stdin.readline().split()))
        while(m + n != -2):
            G[m][0].append(n)
            G[n][0].append(m)
            m,n = list(map(int,stdin.readline().split()))
        #print(G)
        solve(y)
        x,y = list(map(int,stdin.readline().split()))
        print("")
main()

